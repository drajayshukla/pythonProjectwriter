<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>indianfrax</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="indianfrax_files/libs/clipboard/clipboard.min.js"></script>
<script src="indianfrax_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="indianfrax_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="indianfrax_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="indianfrax_files/libs/quarto-html/popper.min.js"></script>
<script src="indianfrax_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="indianfrax_files/libs/quarto-html/anchor.min.js"></script>
<link href="indianfrax_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="indianfrax_files/libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="indianfrax_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="indianfrax_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="indianfrax_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Osteoporosis constitutes a “silent epidemic” in India, characterized by fractures occurring 10–20 years earlier than in Caucasian populations <span class="citation" data-cites="mithal2014">[@mithal2014]</span>. Despite high prevalence, screening is often neglected due to poor awareness and infrastructure gaps <span class="citation" data-cites="unnanuntana2010">[@unnanuntana2010]</span>. To address this, the World Health Organization (WHO) released the India-specific FRAX® model, designed to calibrate risk based on local epidemiology <span class="citation" data-cites="kanis2002 kanis2008">[@kanis2002; @kanis2008]</span>. However, the internal logic of this calculation remains opaque. While the tool is widely available, the specific mathematical penalty assigned to risk factors such as Rheumatoid Arthritis or Glucocorticoid exposure in the Indian context is unknown.</p>
<p>A major barrier to the widespread utility of FRAX in India is the limited availability of Dual-Energy X-ray Absorptiometry (DXA). Consequently, there is intense interest in “Clinical-Only” risk assessment. However, landmark studies in Western populations challenge the validity of this approach. Allbritton-King et al. <span class="citation" data-cites="allbritton2020">[-@allbritton2020]</span>, in their analysis of the Study of Osteoporotic Fractures (SOF) cohort, demonstrated that removing BMD from the FRAX model substantially degraded hip fracture prediction accuracy (<span class="math inline">\(R^2\)</span> reduction from 0.82 to 0.68). They concluded that “all included variables are necessarily included” and warned that simplified models risk misclassifying patients.</p>
<p>It remains unproven whether this “BMD-Essentiality” holds true for the Indian FRAX model. Furthermore, meta-analyses suggest that the protective effect of BMI on fracture risk is non-linear and ethnicity-dependent <span class="citation" data-cites="johansson2009">[@johansson2009]</span>. Given the distinct anthropometric and genetic profile of the South Asian population, we hypothesize that the Indian algorithm relies more heavily on clinical proxies than its Western counterparts.</p>
<p>This study utilizes a computational “First Principles” approach to:</p>
<ol type="1">
<li><strong>Reverse-engineer</strong> the Indian FRAX algorithm using a “Digital Twin” methodology.</li>
<li><strong>Evaluate</strong> the stability of the model when BMD is omitted, directly testing the findings of Allbritton-King et al.&nbsp;in an Indian context.</li>
<li><strong>Derive</strong> mathematically absolute clinical heuristics (“Sentinel Phenotypes”) to empower treatment decisions in non-DXA settings.</li>
</ol>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<section id="data-generation-the-titan-scraper" class="level2">
<h2 class="anchored" data-anchor-id="data-generation-the-titan-scraper">Data Generation (The “Titan” Scraper)</h2>
<p>To overcome the “Black Box” limitation, we developed a custom Python script using the Selenium library to automate data retrieval from the official FRAX website (https://www.fraxplus.org). A synthetic cohort of <strong>15,293 virtual patients</strong> was generated using Monte Carlo sampling to ensure uniform distribution across the physiological risk space:</p>
<ul>
<li><strong>Age:</strong> 40 to 90 years.</li>
<li><strong>BMI:</strong> 15 to 40 kg/m².</li>
<li><strong>T-Score:</strong> -4.0 to +0.5 (Femoral Neck).</li>
<li><strong>Clinical Risk Factors (CRFs):</strong> Randomized permutations of the 7 binary risk factors (Previous Fracture, Parent Hip Fracture, Smoking, Glucocorticoids, Rheumatoid Arthritis, Secondary Osteoporosis, Alcohol).</li>
</ul>
</section>
<section id="mathematical-modeling" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-modeling">Mathematical Modeling</h2>
<p>We fitted Ordinary Least Squares (OLS) regression models to the natural logarithm (<span class="math inline">\(\ln\)</span>) of the FRAX output (MOF and Hip Fracture probabilities). To capture the non-linear “mortality bend” (where fracture risk competes with mortality risk at advanced ages), we utilized <strong>Restricted Cubic Splines (RCS)</strong> for age terms rather than simple linear coefficients.</p>
<p>Two distinct models were constructed to test our hypothesis:</p>
<ul>
<li><strong>Model A (The Gold Standard):</strong> Inputs included Age, BMI, CRFs, and <strong>T-Score</strong>.</li>
<li><strong>Model B (The Clinical Twin):</strong> Inputs included Age, BMI, and CRFs (<strong>T-Score Excluded</strong>).</li>
</ul>
</section>
<section id="statistical-validation" class="level2">
<h2 class="anchored" data-anchor-id="statistical-validation">Statistical Validation</h2>
<p>Model performance was evaluated using the Coefficient of Determination (<span class="math inline">\(R^2\)</span>) and Mean Absolute Error (MAE). The “Cost of Omission” was calculated as the difference in <span class="math inline">\(R^2\)</span> between Model A and Model B.</p>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<section id="model-accuracy-and-bmd-resilience" class="level2">
<h2 class="anchored" data-anchor-id="model-accuracy-and-bmd-resilience">Model Accuracy and BMD Resilience</h2>
<p>The “Digital Twin” demonstrated exceptional fidelity to the official Indian FRAX tool.</p>
<ul>
<li><strong>Model A (With BMD):</strong> <span class="math inline">\(R^2 = 0.9366\)</span></li>
<li><strong>Model B (Clinical Only):</strong> <span class="math inline">\(R^2 = 0.9366\)</span></li>
</ul>
<p>In direct contrast to the findings of Allbritton-King et al.&nbsp;in the US cohort, the removal of BMD from the Indian model resulted in a <strong>negligible loss of predictive power</strong> (<span class="math inline">\(\Delta R^2 &lt; 0.0001\)</span>). This suggests that in the Indian algorithm, the variance in fracture risk is almost entirely explained by Age, BMI, and Clinical Risk Factors, with BMD providing minimal additive information for the final probability score.</p>
</section>
<section id="the-reverse-engineered-equation-mof" class="level2">
<h2 class="anchored" data-anchor-id="the-reverse-engineered-equation-mof">The Reverse-Engineered Equation (MOF)</h2>
<p>Our regression analysis derived the following coefficients for the Indian Major Osteoporotic Fracture (MOF) probability. This equation allows for offline calculation:</p>
<p><span class="math display">\[
\begin{aligned}
\ln(\text{MOF \%}) &amp;= 0.64 + f_{\text{RCS}}(\text{Age}) \\
&amp;\quad - 0.028(\text{BMI}) + 0.0018(\text{T-Score}) \\
&amp;\quad + 1.46(\text{PrevFx}) + 0.58(\text{ParentHip}) \\
&amp;\quad + 0.40(\text{Steroids}) + 0.17(\text{RA}) \\
&amp;\quad + 0.17(\text{SecOsteo}) + 0.23(\text{Alcohol}) \\
&amp;\quad - 0.013(\text{Age} \times \text{PrevFx})
\end{aligned}
\]</span></p>
<p><em>Note: <span class="math inline">\(f_{\text{RCS}}(\text{Age})\)</span> represents the non-linear age spline function.</em></p>
</section>
<section id="the-hierarchy-of-risk-history-vs.-genetics" class="level2">
<h2 class="anchored" data-anchor-id="the-hierarchy-of-risk-history-vs.-genetics">The Hierarchy of Risk: History vs.&nbsp;Genetics</h2>
<p>Forensic analysis of the regression coefficients revealed a stark difference in risk weighting compared to published US models. Table 1 illustrates this divergence.</p>
<p>While Allbritton-King et al.&nbsp;identified Parental History as the primary driver in the US, the Indian algorithm weights a patient’s <em>personal</em> fracture history nearly <strong>2.5 times higher</strong> than their family history.</p>
</section>
<section id="the-tight-coupling-phenomenon" class="level2">
<h2 class="anchored" data-anchor-id="the-tight-coupling-phenomenon">The “Tight Coupling” Phenomenon</h2>
<p>We analyzed “Divergent Cases”—defined as patients meeting the treatment threshold for MOF (<span class="math inline">\(\ge 20\%\)</span>) but failing to meet the threshold for Hip Fracture (<span class="math inline">\(&lt; 3\%\)</span>).</p>
<ul>
<li><strong>US Divergence (Allbritton-King):</strong> 1.8% of cases.</li>
<li><strong>Indian Divergence (Current Study):</strong> <strong>0.0%</strong> of cases.</li>
</ul>
<p>In the Indian model, MOF and Hip risk are tightly coupled. Mathematically, any Indian patient with an MOF risk <span class="math inline">\(\ge 20\%\)</span> effectively guarantees a Hip risk <span class="math inline">\(&gt; 3\%\)</span>.</p>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<section id="rebutting-the-parsimony-penalty" class="level2">
<h2 class="anchored" data-anchor-id="rebutting-the-parsimony-penalty">Rebutting the “Parsimony Penalty”</h2>
<p>The central argument of Allbritton-King et al.&nbsp;is that simplified FRAX models (without BMD) are inherently inferior. Our data decisively refutes this for the Indian population. The statistical resilience of our Model B (<span class="math inline">\(R^2 = 0.9366\)</span>) indicates that the Indian algorithm is designed with a <strong>“High Clinical Pre-Test Probability.”</strong> It appears that the base hazard rates for Indian patients are calibrated such that clinical history (specifically prior fractures) serves as a sufficient proxy for skeletal fragility, rendering the T-score mathematically redundant for risk stratification.</p>
</section>
<section id="the-role-of-bmi-in-the-indian-context" class="level2">
<h2 class="anchored" data-anchor-id="the-role-of-bmi-in-the-indian-context">The Role of BMI in the Indian Context</h2>
<p>Consistent with the meta-analysis by Johansson et al. <span class="citation" data-cites="johansson2009">[-@johansson2009]</span>, we observed a protective effect of BMI (<span class="math inline">\(\beta = -0.028\)</span>). However, our Indian model shows a distinct interaction where the protective benefit of BMI persists independently of BMD. This suggests that the algorithm accounts for the “Soft Tissue Padding” effect, which is particularly relevant in the Indian elderly population where low BMI is a stronger marker for frailty than in Western cohorts <span class="citation" data-cites="unnanuntana2010">[@unnanuntana2010]</span>.</p>
</section>
<section id="the-sentinel-phenotype-strategy" class="level2">
<h2 class="anchored" data-anchor-id="the-sentinel-phenotype-strategy">The “Sentinel Phenotype” Strategy</h2>
<p>The aggressive weighting of <strong>Previous Fracture</strong> (<span class="math inline">\(\beta = 1.46\)</span>) allows us to derive “Sentinel Phenotypes”—clinical profiles that cross treatment thresholds with near-certainty, regardless of BMD.</p>
<p>Based on our heuristics:</p>
<ol type="1">
<li><strong>Women <span class="math inline">\(\ge 65\)</span> years + Prior Fracture:</strong> <span class="math inline">\(&gt;99.2\%\)</span> probability of exceeding the intervention threshold.</li>
<li><strong>Women <span class="math inline">\(\ge 70\)</span> years + Parental Hip Fracture:</strong> <span class="math inline">\(&gt;99.8\%\)</span> probability of exceeding the intervention threshold.</li>
</ol>
<p>In these groups, “Wait and Watch” for a DXA scan is not evidence-based practice; it is a delay in care. The algorithm has already made the decision based on history alone.</p>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<p>This study reverse-engineers the <em>algorithm</em>, not the biological reality. We analyzed how the FRAX tool <em>thinks</em>, which reflects the epidemiological data fed into it. While we cannot validate if the FRAX tool itself is perfectly calibrated to current Indian fracture rates, we have successfully decoded its decision-making logic.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The Indian FRAX algorithm is a unique mathematical entity, distinct from its Western counterparts. It is characterized by <strong>“BMD-Resilience”</strong> and an aggressive weighting of personal fracture history.</p>
<p>Contrary to the warnings of Allbritton-King et al., we conclude that for the Indian population, <strong>Clinical-Only Risk Assessment is not a compromise—it is a robust standard.</strong> We propose a “Clinical-First” screening strategy: patients meeting the “Sentinel Phenotype” criteria should be considered for immediate pharmacotherapy, bypassing the DXA bottleneck to capture the fracture before it recurs.</p>
</section>
<section id="declarations" class="level1">
<h1>Declarations</h1>
<p><strong>Funding:</strong> This study was conducted as an independent investigator-led initiative using open-source computational tools. No external funding was utilized.</p>
<p><strong>Availability of Data:</strong> The “Digital Twin” Python code and regression coefficients are available in the Supplementary Appendix.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" role="list">

</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>